参考文章：https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html

# 一、题目

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

* 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

* 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

示例 1：

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 
```

示例 2：

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 
```

示例 3：

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```


提示：

* 1 <= nums.length <= 1000
* 0 <= nums[i] <= 1000

来源：力扣（LeetCode）链接：https://leetcode.cn/problems/wiggle-subsequence

# 二、题解

本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？

用示例二来举例，如图所示：

![376.摆动序列](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png)

**局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值**。

**整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列**。

局部最优推出全局最优，并举不出反例，那么试试贪心！

（为方便表述，以下说的峰值都是指局部峰值）

**实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）**

**这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点**

在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果`prediff < 0 && curdiff > 0` 或者 `prediff > 0 && curdiff < 0` ，此时就有波动就需要统计。

这是我们思考本题的一个大题思路，但本题的难点在于要考虑完整三种情况：

1. 情况一：上下坡中有平坡
2. 情况二：数组首尾两端
3. 情况三：单调坡中有平坡

## 情况一：上下坡中有平坡

例如 [1,2,2,2,1]这样的数组，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106170449.png)

它的摇摆序列长度是多少呢？ **其实是 3**，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。

如图，可以统一规则，删除左边的三个 2：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106172613.png)

在图中，当 i 指向第一个 2 的时候，`prediff > 0 && curdiff = 0` ，当 i 指向最后一个 2 的时候 `prediff = 0 && curdiff < 0`。

如果我们采用删左面三个 2 的规则，那么 当 `prediff = 0 && curdiff < 0` 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。

所以我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`，为什么这里允许 prediff == 0 ，就是为了 上面这种情况。

## 情况二：数组首尾两端

本题统计峰值的时候，数组最左面和最右面如何统计呢？

题目中说了，如果只有两个不同的元素，那摆动序列也是 2。例如序列 [2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。

因为在计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]）的时候，至少需要三个数字才能计算，而数组只有两个数字。

这里可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。

不写死的话，如何和判断规则结合在一起呢？

可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？

在情况一：相同数字连续 中， prediff = 0 ，curdiff < 0 或者 >0 也记为峰值。

为了规则统一，针对序列 [2,5]，可以假设为 [2,2,5]，这样它就有坡度了即 preDiff = 0，如图：

![376.摆动序列1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174357612.png)

所以为了默认第一个元素前面会延长一段，preDiff 应初始化为 0。而为了默认最右面有一个峰值，result 应初始化为 1。此时 curDiff > 0 && preDiff <= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）

经过以上分析后，我们可以写出如下代码：

```cpp
public class T736 {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length<=1){
            return nums.length;
        }
        int curDiff = 0;//当前元素与其后面元素的差值
        int preDiff = 0;//当前元素与其前面元素的差值,初始化为0是为了默认第一个元素前面会延长一段
        int result = 1;// 记录峰值个数，序列默认序列最右边有一个峰值

        //最右边元素默认有一个波动，所以遍历到倒数第二个元素就行
        for (int i = 0; i < nums.length - 1; i++) {
            curDiff = nums[i+1]-nums[i];
            //出现峰值
            if ((preDiff<=0 && curDiff>0) || (preDiff>=0 && curDiff<0)){
                result++;
            }
            preDiff=curDiff;//preDiff跟着curDiff变化
        }
        return result;
    }
}
```

* 时间复杂度：O(n)
* 空间复杂度：O(1)

此时代码提交了仍不能通过本题？所以要讨论情况三！

## 情况三：单调坡度有平坡

在版本一中，忽略了一种情况，即 如果在一个单调坡度上有平坡，例如 [1,2,2,2,3,4]，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png)

图中可以看出，上面的代码在三个地方记录峰值，但其实结果是 2，因为 单调中的平坡 不能算峰值（即摆动）。

之所以会出问题，是因为 preDiff 一直在跟着 curDiff 更新，其实没有必要。只需要在 这个坡度 摆动变化的时候，更新 preDiff 就行，这样 preDiff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。所以只需把语句`preDiff = curDiff;`放入判断峰值的 if 语句中即可

**本题异常情况的本质，就是要考虑平坡**， 平坡分两种，一个是 上下中间有平坡，一个是单调有平坡，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230108174452.png)

# 三、代码

```java
public class T736 {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length<=1){
            return nums.length;
        }
        int curDiff = 0;//当前元素与其后面元素的差值
        int preDiff = 0;//当前元素与其前面元素的差值,初始化为0是为了默认第一个元素前面会延长一段
        int result = 1;// 记录峰值个数，序列默认序列最右边有一个峰值

        //最右边元素默认有一个波动，所以遍历到倒数第二个元素就行
        for (int i = 0; i < nums.length - 1; i++) {
            curDiff = nums[i+1]-nums[i];
            //出现峰值
            if ((preDiff<=0 && curDiff>0) || (preDiff>=0 && curDiff<0)){
                result++;
                preDiff=curDiff;//只在摆动变化的时候更新preDiff
            }
        }
        return result;
    }
}
```

