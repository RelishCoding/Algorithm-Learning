**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

**但贪心算法并没有固定的套路**。

参考文章：代码随想录https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html

# 一、题目

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

示例 2:

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```


提示：

* 1 <= g.length <= 3 * 104
* 0 <= s.length <= 3 * 104
* 1 <= g[i], s[j] <= 231 - 1

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/assign-cookies

# 二、题解

## 方法一

优先考虑胃口，先喂饱大胃口。

将饼干数组和小孩数组排序。先从后向前遍历胃口，再从后向前遍历饼干，大饼干优先满足胃口大的，并统计满足小孩数量。

遍历饼干不需要再写一个 for 循环，因为饼干数组已经按从小到大排序，从数组末尾开始遍历，若最大的饼干都满足不了胃口，那前面的饼干肯定也无法满足。可以用一个 index 来控制饼干数组的遍历，采用自减的方式，这也是常用的技巧。

注意：不可以先遍历饼干，再遍历胃口。

这样写，如果一开始最大的饼干就无法满足最大的胃口，胃口数组的 index 不会移动，反而饼干数组持续向前遍历，却一直无法满足，最终满足的小孩数量为 0 。

![](E:\Git-Space\Algorithm-Learning\贪心\img\image1.png)

## 方法二

优先考虑饼干，小饼干先喂饱小胃口。

将饼干数组和小孩数组排序。先从前往后遍历饼干，再从前往后遍历胃口，小饼干优先满足胃口小的，并统计满足小孩数量。

注意：不可以先遍历胃口，再遍历饼干。

同理，如果一开始最小的饼干就无法满足最小的胃口，饼干数组的 index 不会移动，反而胃口数组持续向后遍历，一直找不到满足胃口的饼干，最终满足的小孩数量为 0 。

# 三、代码

## 方法一

```java
import java.util.Arrays;

public class T455 {
    // 思路1：优先考虑胃口，先喂饱大胃口
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int count=0;
        int index=s.length-1;
        for (int i=g.length-1;i>=0;i--){
            //先判断index是否越界，再判断饼干和胃口的大小关系
            if (index>=0 && s[index]>=g[i]){
                count++;
                index--;
            }
        }
        return count;
    }
}
```

## 方法二

```java
import java.util.Arrays;

public class T455 {
    // 思路2：优先考虑饼干，小饼干先喂饱小胃口
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int count=0;
        int index=0;
        for (int i=0;i<s.length;i++){
            //先判断index是否越界，再判断饼干和胃口的大小关系
            if (index<g.length && s[i]>=g[index]){
                count++;
                index++;
            }
        }
        return count;
    }
}
```

